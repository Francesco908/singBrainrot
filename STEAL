-- Enhanced Sing Hub - Professional Auto Game Script with Advanced Logic
-- Version 2.0 - Optimized for Performance and Reliability

local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- Services Declaration with Error Handling
local function safeGetService(serviceName)
    local success, service = pcall(function()
        return game:GetService(serviceName)
    end)
    if success then
        return service
    else
        warn("Failed to get service: " .. serviceName)
        return nil
    end
end

local Players = safeGetService("Players")
local RunService = safeGetService("RunService")
local Workspace = safeGetService("Workspace")
local ProximityPromptService = safeGetService("ProximityPromptService")
local UserInputService = safeGetService("UserInputService")
local TweenService = safeGetService("TweenService")
local MarketplaceService = safeGetService("MarketplaceService")
local HttpService = safeGetService("HttpService")
local ReplicatedStorage = safeGetService("ReplicatedStorage")
local DataStoreService = safeGetService("DataStoreService")

-- Advanced Configuration System
local Config = {
    Performance = {
        MaxSearchRadius = 500,
        UpdateInterval = 0.1,
        PathfindingEnabled = true,
        AntiLagMode = false,
        MaxItemsPerCycle = 10
    },
    
    Priorities = {
        RobuxItems = 100,
        RareItems = 90,
        Money = 80,
        CommonItems = 70,
        Eggs = 60,
        SellAreas = 50
    },
    
    Economy = {
        MinMoneyThreshold = 1000,
        AutoSellThreshold = 100,
        PremiumMultiplier = 2.0,
        RobuxItemTracking = true
    },
    
    Safety = {
        AntiDetection = true,
        RandomizedMovement = true,
        HumanlikeBehavior = true,
        MaxActionsPerMinute = 120
    }
}

-- Enhanced Variables with State Management
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")
local camera = Workspace.CurrentCamera

-- State Management System
local GameState = {
    Stats = {
        ItemsCollected = 0,
        MoneyEarned = 0,
        EggsPurchased = 0,
        RobuxItemsFound = 0,
        SessionStartTime = tick(),
        LastActionTime = tick()
    },
    
    Inventory = {
        Items = {},
        Money = 0,
        PremiumCurrency = 0
    },
    
    ActiveModes = {
        AutoFarm = false,
        AutoBuy = false,
        AutoGame = false,
        ESP = false,
        Fly = false,
        PremiumMode = false
    },
    
    Performance = {
        FPS = 0,
        Ping = 0,
        MemoryUsage = 0
    }
}

-- Advanced Object Detection System
local ObjectDetector = {}

function ObjectDetector:new()
    local detector = {}
    setmetatable(detector, self)
    self.__index = self
    
    detector.cache = {}
    detector.lastUpdate = 0
    detector.updateInterval = 1
    
    return detector
end

function ObjectDetector:categorizeObject(obj)
    if not obj or not obj.Parent then return nil end
    
    local name = obj.Name:lower()
    local attributes = obj:GetAttributes()
    
    -- Check for Robux items
    if attributes.RequiresRobux or name:find("premium") or name:find("robux") then
        return "RobuxItem", Config.Priorities.RobuxItems
    end
    
    -- Check for rare items
    if attributes.Rarity and attributes.Rarity >= 4 or name:find("legendary") or name:find("epic") then
        return "RareItem", Config.Priorities.RareItems
    end
    
    -- Standard categorization
    if name:match("^item%d*$") or name:find("collect") then
        return "CommonItem", Config.Priorities.CommonItems
    elseif name:match("^egg%d*$") or name:find("hatch") then
        return "Egg", Config.Priorities.Eggs
    elseif name:find("money") or name:find("cash") or name:find("coin") or name:find("currency") then
        return "Money", Config.Priorities.Money
    elseif name:find("sell") or name:find("shop") or name:find("merchant") or name:find("vendor") then
        return "SellArea", Config.Priorities.SellAreas
    end
    
    return nil
end

function ObjectDetector:findObjectsInRadius(position, radius)
    local objects = {}
    
    for _, obj in pairs(Workspace:GetDescendants()) do
        if obj:IsA("BasePart") or obj:IsA("Model") then
            local objPos = obj:IsA("Model") and obj:GetModelCFrame().Position or obj.Position
            local distance = (position - objPos).Magnitude
            
            if distance <= radius then
                local category, priority = self:categorizeObject(obj)
                if category then
                    table.insert(objects, {
                        Object = obj,
                        Category = category,
                        Priority = priority,
                        Distance = distance,
                        Position = objPos
                    })
                end
            end
        end
    end
    
    -- Sort by priority and distance
    table.sort(objects, function(a, b)
        if a.Priority == b.Priority then
            return a.Distance < b.Distance
        end
        return a.Priority > b.Priority
    end)
    
    return objects
end

-- Intelligent Pathfinding System
local Pathfinder = {}

function Pathfinder:new()
    local pf = {}
    setmetatable(pf, self)
    self.__index = self
    
    pf.waypoints = {}
    pf.currentWaypoint = 1
    pf.stuck = false
    pf.lastPosition = Vector3.new()
    pf.stuckTimer = 0
    
    return pf
end

function Pathfinder:createPath(startPos, endPos)
    self.waypoints = {}
    
    -- Simple A* implementation for obstacle avoidance
    local direction = (endPos - startPos).Unit
    local distance = (endPos - startPos).Magnitude
    local steps = math.max(5, math.floor(distance / 10))
    
    for i = 1, steps do
        local waypoint = startPos + direction * (distance * (i / steps))
        
        -- Check for obstacles
        local ray = workspace:Raycast(
            i == 1 and startPos or self.waypoints[i-1],
            waypoint - (i == 1 and startPos or self.waypoints[i-1])
        )
        
        if ray then
            -- Obstacle detected, try to find alternative path
            local alternatives = {
                waypoint + Vector3.new(5, 0, 0),
                waypoint + Vector3.new(-5, 0, 0),
                waypoint + Vector3.new(0, 0, 5),
                waypoint + Vector3.new(0, 0, -5),
                waypoint + Vector3.new(0, 10, 0)
            }
            
            for _, alt in ipairs(alternatives) do
                local altRay = workspace:Raycast(
                    i == 1 and startPos or self.waypoints[i-1],
                    alt - (i == 1 and startPos or self.waypoints[i-1])
                )
                if not altRay then
                    waypoint = alt
                    break
                end
            end
        end
        
        table.insert(self.waypoints, waypoint)
    end
    
    table.insert(self.waypoints, endPos)
    self.currentWaypoint = 1
    
    return self.waypoints
end

function Pathfinder:moveToNext(humanoid, rootPart)
    if not self.waypoints or #self.waypoints == 0 then return false end
    
    local currentTarget = self.waypoints[self.currentWaypoint]
    if not currentTarget then return false end
    
    -- Check if stuck
    local currentPos = rootPart.Position
    if (currentPos - self.lastPosition).Magnitude < 0.5 then
        self.stuckTimer = self.stuckTimer + 0.1
        if self.stuckTimer > 2 then
            self.stuck = true
            -- Try jumping or alternative movement
            humanoid.Jump = true
            wait(0.1)
            humanoid:MoveTo(currentTarget + Vector3.new(math.random(-5, 5), 0, math.random(-5, 5)))
            self.stuckTimer = 0
        end
    else
        self.stuckTimer = 0
        self.stuck = false
    end
    
    self.lastPosition = currentPos
    
    -- Move to waypoint
    local distance = (currentPos - currentTarget).Magnitude
    if distance < 5 then
        self.currentWaypoint = self.currentWaypoint + 1
        if self.currentWaypoint > #self.waypoints then
            return true -- Path completed
        end
    else
        -- Add randomization for human-like movement
        if Config.Safety.RandomizedMovement then
            local randomOffset = Vector3.new(
                math.random(-2, 2),
                0,
                math.random(-2, 2)
            )
            humanoid:MoveTo(currentTarget + randomOffset)
        else
            humanoid:MoveTo(currentTarget)
        end
    end
    
    return false
end

-- Enhanced ESP System with Advanced Visualization
local ESPSystem = {}

function ESPSystem:new()
    local esp = {}
    setmetatable(esp, self)
    self.__index = self
    
    esp.objects = {}
    esp.connections = {}
    esp.tracers = {}
    esp.labels = {}
    
    return esp
end

function ESPSystem:createAdvancedESP(obj, info)
    if not obj or not obj.Parent then return end
    
    -- Create main ESP container
    local espContainer = Instance.new("BillboardGui")
    espContainer.Name = "AdvancedESP"
    espContainer.Size = UDim2.new(0, 200, 0, 100)
    espContainer.StudsOffset = Vector3.new(0, 3, 0)
    espContainer.AlwaysOnTop = true
    espContainer.LightInfluence = 0
    espContainer.Parent = obj
    
    -- Main frame with gradient
    local mainFrame = Instance.new("Frame")
    mainFrame.Size = UDim2.new(1, 0, 1, 0)
    mainFrame.BackgroundTransparency = 0.3
    mainFrame.BorderSizePixel = 0
    mainFrame.Parent = espContainer
    
    local gradient = Instance.new("UIGradient")
    gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, info.Color),
        ColorSequenceKeypoint.new(1, Color3.new(info.Color.R * 0.5, info.Color.G * 0.5, info.Color.B * 0.5))
    })
    gradient.Parent = mainFrame
    
    -- Category label
    local categoryLabel = Instance.new("TextLabel")
    categoryLabel.Size = UDim2.new(1, 0, 0.4, 0)
    categoryLabel.Position = UDim2.new(0, 0, 0, 0)
    categoryLabel.BackgroundTransparency = 1
    categoryLabel.Text = info.Category
    categoryLabel.TextColor3 = Color3.new(1, 1, 1)
    categoryLabel.TextScaled = true
    categoryLabel.Font = Enum.Font.SourceSansBold
    categoryLabel.Parent = mainFrame
    
    -- Distance label
    local distanceLabel = Instance.new("TextLabel")
    distanceLabel.Size = UDim2.new(1, 0, 0.3, 0)
    distanceLabel.Position = UDim2.new(0, 0, 0.4, 0)
    distanceLabel.BackgroundTransparency = 1
    distanceLabel.Text = "0m"
    distanceLabel.TextColor3 = Color3.new(0.8, 0.8, 0.8)
    distanceLabel.TextScaled = true
    distanceLabel.Font = Enum.Font.SourceSans
    distanceLabel.Parent = mainFrame
    
    -- Value label (if applicable)
    local valueLabel = Instance.new("TextLabel")
    valueLabel.Size = UDim2.new(1, 0, 0.3, 0)
    valueLabel.Position = UDim2.new(0, 0, 0.7, 0)
    valueLabel.BackgroundTransparency = 1
    valueLabel.Text = info.Value or ""
    valueLabel.TextColor3 = Color3.new(1, 0.8, 0)
    valueLabel.TextScaled = true
    valueLabel.Font = Enum.Font.SourceSansBold
    valueLabel.Parent = mainFrame
    
    -- Create tracer line
    local tracer = Drawing.new("Line")
    tracer.Color = info.Color
    tracer.Thickness = 2
    tracer.Transparency = 0.5
    
    -- Store references
    self.objects[obj] = {
        Container = espContainer,
        DistanceLabel = distanceLabel,
        Tracer = tracer,
        Info = info
    }
    
    -- Update connection
    local updateConnection = RunService.RenderStepped:Connect(function()
        if obj and obj.Parent and rootPart then
            local objPos = obj:IsA("Model") and obj:GetModelCFrame().Position or obj.Position
            local distance = (rootPart.Position - objPos).Magnitude
            
            distanceLabel.Text = string.format("%.1fm", distance)
            
            -- Update tracer
            local screenPos, onScreen = camera:WorldToScreenPoint(objPos)
            if onScreen then
                tracer.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y)
                tracer.To = Vector2.new(screenPos.X, screenPos.Y)
                tracer.Visible = true
            else
                tracer.Visible = false
            end
            
            -- Fade based on distance
            local transparency = math.min(distance / 200, 0.8)
            mainFrame.BackgroundTransparency = transparency
        else
            self:removeESP(obj)
        end
    end)
    
    self.connections[obj] = updateConnection
end

function ESPSystem:removeESP(obj)
    if self.objects[obj] then
        if self.objects[obj].Container then
            self.objects[obj].Container:Destroy()
        end
        if self.objects[obj].Tracer then
            self.objects[obj].Tracer:Remove()
        end
    end
    
    if self.connections[obj] then
        self.connections[obj]:Disconnect()
        self.connections[obj] = nil
    end
    
    self.objects[obj] = nil
end

function ESPSystem:updateAll()
    local detector = ObjectDetector:new()
    local objects = detector:findObjectsInRadius(rootPart.Position, Config.Performance.MaxSearchRadius)
    
    -- Remove ESP for objects no longer in range
    for obj, _ in pairs(self.objects) do
        local found = false
        for _, objData in ipairs(objects) do
            if objData.Object == obj then
                found = true
                break
            end
        end
        if not found then
            self:removeESP(obj)
        end
    end
    
    -- Add ESP for new objects
    for _, objData in ipairs(objects) do
        if not self.objects[objData.Object] then
            local color = Color3.new(1, 1, 1)
            local value = ""
            
            if objData.Category == "RobuxItem" then
                color = Color3.new(1, 0, 1) -- Magenta for Robux items
                value = "PREMIUM"
            elseif objData.Category == "RareItem" then
                color = Color3.new(1, 0.5, 0) -- Orange for rare items
                value = "RARE"
            elseif objData.Category == "Money" then
                color = Color3.new(0, 1, 0) -- Green for money
                value = "$$$"
            elseif objData.Category == "Egg" then
                color = Color3.new(1, 1, 0) -- Yellow for eggs
            elseif objData.Category == "SellArea" then
                color = Color3.new(0, 0, 1) -- Blue for sell areas
            end
            
            self:createAdvancedESP(objData.Object, {
                Category = objData.Category,
                Color = color,
                Value = value
            })
        end
    end
end

-- Advanced Interaction System
local InteractionSystem = {}

function InteractionSystem:new()
    local interaction = {}
    setmetatable(interaction, self)
    self.__index = self
    
    interaction.queue = {}
    interaction.processing = false
    interaction.cooldowns = {}
    
    return interaction
end

function InteractionSystem:canInteract(obj)
    if not obj or not obj.Parent then return false end
    
    -- Check cooldown
    local objId = obj:GetDebugId()
    if self.cooldowns[objId] and tick() - self.cooldowns[objId] < 1 then
        return false
    end
    
    -- Check safety limits
    local recentActions = 0
    for _, cooldown in pairs(self.cooldowns) do
        if tick() - cooldown < 60 then
            recentActions = recentActions + 1
        end
    end
    
    if Config.Safety.AntiDetection and recentActions >= Config.Safety.MaxActionsPerMinute then
        return false
    end
    
    return true
end

function InteractionSystem:interactWithObject(obj)
    if not self:canInteract(obj) then return false end
    
    local success = false
    
    -- Try multiple interaction methods
    local methods = {
        -- Method 1: ProximityPrompt
        function()
            local prompt = obj:FindFirstChildOfClass("ProximityPrompt") or 
                          obj:FindFirstDescendantOfClass("ProximityPrompt")
            if prompt then
                prompt.HoldDuration = 0
                prompt:InputHoldBegin()
                wait(0.05)
                prompt:InputHoldEnd()
                return true
            end
            return false
        end,
        
        -- Method 2: ClickDetector
        function()
            local click = obj:FindFirstChildOfClass("ClickDetector") or 
                         obj:FindFirstDescendantOfClass("ClickDetector")
            if click then
                fireclickdetector(click)
                return true
            end
            return false
        end,
        
        -- Method 3: RemoteEvent
        function()
            local remote = obj:FindFirstChildOfClass("RemoteEvent") or
                          ReplicatedStorage:FindFirstChild("CollectItem") or
                          ReplicatedStorage:FindFirstChild("InteractRemote")
            if remote then
                remote:FireServer(obj)
                return true
            end
            return false
        end,
        
        -- Method 4: Touch simulation
        function()
            if obj:IsA("BasePart") then
                firetouchinterest(rootPart, obj, 0)
                wait(0.05)
                firetouchinterest(rootPart, obj, 1)
                return true
            end
            return false
        end
    }
    
    for _, method in ipairs(methods) do
        local methodSuccess = method()
        if methodSuccess then
            success = true
            break
        end
    end
    
    if success then
        self.cooldowns[obj:GetDebugId()] = tick()
        GameState.Stats.ItemsCollected = GameState.Stats.ItemsCollected + 1
        
        -- Track special items
        local detector = ObjectDetector:new()
        local category = detector:categorizeObject(obj)
        if category == "RobuxItem" then
            GameState.Stats.RobuxItemsFound = GameState.Stats.RobuxItemsFound + 1
        end
    end
    
    return success
end

-- Robux Item Handler
local RobuxHandler = {}

function RobuxHandler:checkPremiumStatus()
    local success, isPremium = pcall(function()
        return player.MembershipType == Enum.MembershipType.Premium
    end)
    return success and isPremium
end

function RobuxHandler:processRobuxItem(item)
    if not item or not item.Parent then return false end
    
    -- Check if player has premium
    local hasPremium = self:checkPremiumStatus()
    
    -- Try to find product ID
    local productId = item:GetAttribute("ProductId") or item:GetAttribute("GamepassId")
    
    if productId then
        -- Check if already owned
        local success, owns = pcall(function()
            return MarketplaceService:UserOwnsGamePassAsync(player.UserId, productId)
        end)
        
        if success and owns then
            -- Already owns, can collect
            return true
        else
            -- Notify about premium item
            Rayfield:Notify({
                Title = "Premium Item Found!",
                Content = "This item requires Robux. Product ID: " .. tostring(productId),
                Duration = 5,
                Image = 4483362458,
                Actions = {
                    Ignore = {
                        Name = "Ignore",
                        Callback = function() end
                    }
                }
            })
            return false
        end
    end
    
    return hasPremium
end

-- Main Automation Engine
local AutomationEngine = {}

function AutomationEngine:new()
    local engine = {}
    setmetatable(engine, self)
    self.__index = self
    
    engine.detector = ObjectDetector:new()
    engine.pathfinder = Pathfinder:new()
    engine.interaction = InteractionSystem:new()
    engine.currentTarget = nil
    engine.state = "idle"
    
    return engine
end

function AutomationEngine:selectBestTarget()
    local objects = self.detector:findObjectsInRadius(rootPart.Position, Config.Performance.MaxSearchRadius)
    
    if #objects == 0 then return nil end
    
    -- Apply intelligent filtering
    local validTargets = {}
    
    for _, obj in ipairs(objects) do
        local isValid = true
        
        -- Check if it's a Robux item and if we can collect it
        if obj.Category == "RobuxItem" then
            isValid = RobuxHandler:processRobuxItem(obj.Object)
        end
        
        -- Check inventory limits
        if obj.Category == "CommonItem" and #GameState.Inventory.Items >= Config.Economy.AutoSellThreshold then
            isValid = false -- Need to sell first
        end
        
        if isValid then
            table.insert(validTargets, obj)
        end
    end
    
    -- Return highest priority valid target
    return validTargets[1]
end

function AutomationEngine:executeStrategy()
    if not GameState.ActiveModes.AutoGame then return end
    
    -- Performance monitoring
    if Config.Performance.AntiLagMode then
        local fps = 1 / RunService.Heartbeat:Wait()
        if fps < 30 then
            wait(0.5) -- Reduce load
            return
        end
    end
    
    -- State machine
    if self.state == "idle" then
        self.currentTarget = self:selectBestTarget()
        if self.currentTarget then
            self.state = "moving"
            self.pathfinder:createPath(rootPart.Position, self.currentTarget.Position)
        else
            -- No targets, move to sell area
            local sellAreas = self.detector:findObjectsInRadius(rootPart.Position, 1000)
            for _, obj in ipairs(sellAreas) do
                if obj.Category == "SellArea" then
                    self.currentTarget = obj
                    self.state = "moving"
                    self.pathfinder:createPath(rootPart.Position, obj.Position)
                    break
                end
            end
        end
        
    elseif self.state == "moving" then
        if not self.currentTarget or not self.currentTarget.Object.Parent then
            self.state = "idle"
            return
        end
        
        local completed = self.pathfinder:moveToNext(humanoid, rootPart)
        
        if completed then
            self.state = "interacting"
        end
        
        -- Check if close enough to interact while moving
        local distance = (rootPart.Position - self.currentTarget.Position).Magnitude
        if distance < 10 then
            self.state = "interacting"
        end
        
    elseif self.state == "interacting" then
        if not self.currentTarget or not self.currentTarget.Object.Parent then
            self.state = "idle"
            return
        end
        
        local success = self.interaction:interactWithObject(self.currentTarget.Object)
        
        if success then
            -- Add human-like delay
            if Config.Safety.HumanlikeBehavior then
                wait(math.random() * 0.5 + 0.2)
            end
        end
        
        self.state = "idle"
        self.currentTarget = nil
    end
end

-- Performance Monitor
local PerformanceMonitor = {}

function PerformanceMonitor:update()
    local stats = game:GetService("Stats")
    
    GameState.Performance.FPS = math.floor(1 / RunService.Heartbeat:Wait())
    GameState.Performance.Ping = stats.Network.ServerStatsItem["Data Ping"]:GetValue()
    GameState.Performance.MemoryUsage = math.floor(collectgarbage("count"))
    
    -- Auto-adjust settings based on performance
    if GameState.Performance.FPS < 30 then
        Config.Performance.AntiLagMode = true
        Config.Performance.UpdateInterval = 0.2
    elseif GameState.Performance.FPS > 50 then
        Config.Performance.AntiLagMode = false
        Config.Performance.UpdateInterval = 0.1
    end
end

-- Initialize systems
local automationEngine = AutomationEngine:new()
local espSystem = ESPSystem:new()
local performanceMonitor = PerformanceMonitor

-- Create Enhanced UI
local Window = Rayfield:CreateWindow({
    Name = "Sing Hub Professional",
    LoadingTitle = "Sing Hub Pro Loading",
    LoadingSubtitle = "Enhanced Automation System v2.0",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "SingHubProConfig",
        FileName = "EnhancedConfig"
    },
    Discord = {
        Enabled = false,
        Invite = "noinvitelink",
        RememberJoins = true
    },
    KeySystem = false
})

-- Main Tab
local MainTab = Window:CreateTab("üéÆ Main Controls", 4483362458)

-- Master Control Section
local MasterSection = MainTab:CreateSection("Master Controls")

local AutoGameToggle = MainTab:CreateToggle({
    Name = "üöÄ Master Automation",
    CurrentValue = false,
    Flag = "MasterAutomation",
    Callback = function(Value)
        GameState.ActiveModes.AutoGame = Value
        
        if Value then
            -- Start all systems
            humanoid.WalkSpeed = 50
            
            -- Main automation loop
            spawn(function()
                while GameState.ActiveModes.AutoGame do
                    automationEngine:executeStrategy()
                    wait(Config.Performance.UpdateInterval)
                end
            end)
            
            -- Performance monitoring
            spawn(function()
                while GameState.ActiveModes.AutoGame do
                    performanceMonitor:update()
                    wait(1)
                end
            end)
            
            Rayfield:Notify({
                Title = "Master Automation",
                Content = "All systems activated! Intelligent automation engaged.",
                Duration = 4,
                Image = 4483362458
            })
        else
            humanoid.WalkSpeed = 16
            
            Rayfield:Notify({
                Title = "Master Automation",
                Content = "Systems deactivated.",
                Duration = 3,
                Image = 4483362458
            })
        end
    end
})

-- Premium Features Section
local PremiumSection = MainTab:CreateSection("Premium Features")

local PremiumModeToggle = MainTab:CreateToggle({
    Name = "üíé Premium Mode (Robux Items)",
    CurrentValue = false,
    Flag = "PremiumMode",
    Callback = function(Value)
        GameState.ActiveModes.PremiumMode = Value
        Config.Priorities.RobuxItems = Value and 150 or 100
        
        Rayfield:Notify({
            Title = "Premium Mode",
            Content = Value and "Prioritizing Robux items!" or "Premium mode disabled.",
            Duration = 3,
            Image = 4483362458
        })
    end
})

-- Statistics Tab
local StatsTab = Window:CreateTab("üìä Statistics", 4483362458)

local StatsSection = StatsTab:CreateSection("Session Statistics")

local StatsDisplay = StatsTab:CreateParagraph({
    Title = "Live Statistics",
    Content = "Initializing..."
})

-- Update stats display
spawn(function()
    while wait(1) do
        local sessionTime = math.floor(tick() - GameState.Stats.SessionStartTime)
        local hours = math.floor(sessionTime / 3600)
        local minutes = math.floor((sessionTime % 3600) / 60)
        local seconds = sessionTime % 60
        
        local efficiency = GameState.Stats.ItemsCollected > 0 and 
            math.floor((GameState.Stats.ItemsCollected / sessionTime) * 60) or 0
        
        StatsDisplay:Set({
            Title = "Live Statistics",
            Content = string.format(
                "‚è±Ô∏è Session Time: %02d:%02d:%02d\n" ..
                "üì¶ Items Collected: %d\n" ..
                "üí∞ Money Earned: %d\n" ..
                "ü•ö Eggs Purchased: %d\n" ..
                "üíé Robux Items Found: %d\n" ..
                "‚ö° Efficiency: %d items/min\n" ..
                "üñ•Ô∏è FPS: %d | Ping: %dms\n" ..
                "üíæ Memory: %d MB",
                hours, minutes, seconds,
                GameState.Stats.ItemsCollected,
                GameState.Stats.MoneyEarned,
                GameState.Stats.EggsPurchased,
                GameState.Stats.RobuxItemsFound,
                efficiency,
                GameState.Performance.FPS,
                GameState.Performance.Ping,
                GameState.Performance.MemoryUsage / 1024
            )
        })
    end
end)

-- ESP Tab
local ESPTab = Window:CreateTab("üëÅÔ∏è Enhanced ESP", 4483362458)

local ESPToggle = ESPTab:CreateToggle({
    Name = "Advanced ESP System",
    CurrentValue = false,
    Flag = "AdvancedESP",
    Callback = function(Value)
        GameState.ActiveModes.ESP = Value
        
        if Value then
            spawn(function()
                while GameState.ActiveModes.ESP do
                    espSystem:updateAll()
                    wait(0.5)
                end
            end)
            
            Rayfield:Notify({
                Title = "Enhanced ESP",
                Content = "Advanced visualization enabled!",
                Duration = 3,
                Image = 4483362458
            })
        else
            -- Clear all ESP
            for obj, _ in pairs(espSystem.objects) do
                espSystem:removeESP(obj)
            end
            
            Rayfield:Notify({
                Title = "Enhanced ESP",
                Content = "Visualization disabled.",
                Duration = 3,
                Image = 4483362458
            })
        end
    end
})

-- Settings Tab
local SettingsTab = Window:CreateTab("‚öôÔ∏è Advanced Settings", 4483362458)

local PerformanceSection = SettingsTab:CreateSection("Performance Settings")

local AntiLagToggle = SettingsTab:CreateToggle({
    Name = "Anti-Lag Mode",
    CurrentValue = false,
    Flag = "AntiLagMode",
    Callback = function(Value)
        Config.Performance.AntiLagMode = Value
    end
})

local SearchRadiusSlider = SettingsTab:CreateSlider({
    Name = "Search Radius",
    Range = {100, 1000},
    Increment = 50,
    Suffix = " studs",
    CurrentValue = 500,
    Flag = "SearchRadius",
    Callback = function(Value)
        Config.Performance.MaxSearchRadius = Value
    end
})

local SafetySection = SettingsTab:CreateSection("Safety Settings")

local AntiDetectionToggle = SettingsTab:CreateToggle({
    Name = "Anti-Detection System",
    CurrentValue = true,
    Flag = "AntiDetection",
    Callback = function(Value)
        Config.Safety.AntiDetection = Value
    end
})

local HumanBehaviorToggle = SettingsTab:CreateToggle({
    Name = "Human-like Behavior",
    CurrentValue = true,
    Flag = "HumanBehavior",
    Callback = function(Value)
        Config.Safety.HumanlikeBehavior = Value
    end
})

-- Character respawn handling
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
    rootPart = character:WaitForChild("HumanoidRootPart")
    
    -- Reinitialize systems
    automationEngine = AutomationEngine:new()
    
    wait(1)
    
    if GameState.ActiveModes.AutoGame then
        humanoid.WalkSpeed = 50
    end
end)

-- Initial notification
Rayfield:Notify({
    Title = "Sing Hub Professional",
    Content = "Enhanced automation system loaded successfully! Version 2.0",
    Duration = 5,
    Image = 4483362458
})

print("Sing Hub Professional - Enhanced automation system initialized!")
